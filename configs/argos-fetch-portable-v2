#!/bin/bash

# ═══════════════════════════════════════════════════════════════════════════════
# 🐺 ARGOS FETCH v2.0 - Optimizado para rendimiento y alineación perfecta
# ═══════════════════════════════════════════════════════════════════════════════
# Script de bienvenida con imagen y texto ASCII lado a lado
# Versión final optimizada - Julio 2025
# ═══════════════════════════════════════════════════════════════════════════════

# --- CONFIGURACIÓN ---
# <<< MEJORA: Se usa un array para buscar en varias rutas. Más flexible. >>>
ARGOS_IMAGE_PATHS=(
    "$HOME/.local/share/argos/loboMacOS.png"
    "$HOME/.config/argos/loboMacOS.png"
    "$HOME/.local/share/argos/argos-image.png"
    "$HOME/.config/argos/argos-image.png"
)

# Ancho de la imagen en celdas de caracteres. AJUSTA ESTOS VALORES.
# Deben coincidir para que la alineación funcione.
IMAGE_WIDTH_ITERM=25
IMAGE_HEIGHT_ITERM=12

IMAGE_WIDTH_CHAFA=30
IMAGE_HEIGHT_CHAFA=15

# --- FUNCIÓN PRINCIPAL ---
# <<< MEJORA: Toda la lógica está encapsulada en una función para poder ejecutarla en segundo plano. >>>
function argos_main() {
    # Pausa optimizada para iTerm2
    sleep 0.05

    # Optimización: Solo limpiar procesos si realmente existen
    local existing_processes
    existing_processes=$(pgrep -f "$(basename "$0")" | grep -v $$)
    if [[ -n "$existing_processes" ]]; then
        echo "$existing_processes" | xargs -r kill &>/dev/null
    fi

    local ARGOS_IMAGE=""
    # Buscar la imagen en las rutas definidas
    for path in "${ARGOS_IMAGE_PATHS[@]}"; do
        if [[ -r "$path" ]]; then # -r verifica que el archivo existe Y se puede leer
            ARGOS_IMAGE="$path"
            break
        fi
    done

    # Si no se encontró ninguna imagen, no mostrar nada y salir limpiamente.
    if [[ -z "$ARGOS_IMAGE" ]]; then
        # echo "⚠️ Imagen ARGOS no encontrada." >&2 # Descomentar para depurar
        return 1
    fi

    # --- Generación de Texto ---
    # <<< MEJORA: El texto se define una sola vez y se reutiliza. >>>
    local USERNAME
    USERNAME=$(whoami)
    local TEXT_INFO
    TEXT_INFO=$(printf "
██████╗ ██████╗  ██████╗  ██████╗ ███████╗
██╔══██╗██╔══██╗██╔════╝ ██╔═══██╗██╔════╝
███████║██████╔╝██║  ███╗██║   ██║███████╗
██╔══██║██╔══██╗██║   ██║██║   ██║╚════██║
██║  ██║██║  ██║╚██████╔╝╚██████╔╝███████║
╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝  ╚═════╝ ╚══════╝

        🐺 W O L F   S Y S T E M 🐺

    👤 %s
" "$USERNAME")

    # Limpiar pantalla antes de dibujar
    clear

    # --- Lógica de Dibujado Lado a Lado ---
    # Optimización: Cache de detección de imgcat
    local IMGCAT_PATH=""
    if [[ -n "${IMGCAT_CACHED:-}" ]]; then
        IMGCAT_PATH="$IMGCAT_CACHED"
    elif command -v imgcat &>/dev/null; then
        IMGCAT_PATH="imgcat"
        export IMGCAT_CACHED="$IMGCAT_PATH"
    elif [[ -x "$HOME/.local/bin/imgcat" ]]; then
        IMGCAT_PATH="$HOME/.local/bin/imgcat"
        export IMGCAT_CACHED="$IMGCAT_PATH"
    elif [[ -x "$(dirname "$0")/imgcat" ]]; then
        IMGCAT_PATH="$(dirname "$0")/imgcat"
        export IMGCAT_CACHED="$IMGCAT_PATH"
    fi

    if [[ "$TERM_PROGRAM" == "iTerm.app" || "$LC_TERMINAL" == "iTerm2" ]] && [[ -n "$IMGCAT_PATH" ]]; then
        # Método optimizado para iTerm2
        "$IMGCAT_PATH" --width "$IMAGE_WIDTH_ITERM" --height "$IMAGE_HEIGHT_ITERM" "$ARGOS_IMAGE"

        # Optimización: Procesamiento de texto más eficiente
        local text_output=""
        local line_num=0
        while IFS= read -r line; do
            text_output+="\033[${line_num};26H${line}\n"
            ((line_num++))
        done <<< "$TEXT_INFO"

        # Imprimir todo el texto de una vez
        printf "$text_output"

    elif command -v chafa &>/dev/null; then
        # Método para otras terminales con 'chafa'
        # <<< MEJORA: Se usa 'paste' con sustitución de procesos, que es más limpio que archivos temporales. >>>
        paste -d' ' \
            <(chafa --symbols=block --size="${IMAGE_WIDTH_CHAFA}x${IMAGE_HEIGHT_CHAFA}" "$ARGOS_IMAGE") \
            <(echo "$TEXT_INFO")
    else
        # Fallback si no hay visor de imágenes: solo mostrar el texto
        echo "$TEXT_INFO"
    fi

    # Salto de línea final para que el prompt no quede pegado
    echo
}

# --- EJECUCIÓN ---
# <<< MEJORA CLAVE: Ejecuta la función directamente para mostrar bienvenida. >>>
# Si se ejecuta desde .zshrc, debe ejecutarse en primer plano para mostrarse correctamente.
argos_main
