#!/bin/bash

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸº ARGOS FETCH v2.0 - Optimizado para rendimiento y alineaciÃ³n perfecta
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Script de bienvenida con imagen y texto ASCII lado a lado
# VersiÃ³n final optimizada - Julio 2025
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# --- CONFIGURACIÃ“N ---
# <<< MEJORA: Se usa un array para buscar en varias rutas. MÃ¡s flexible. >>>
ARGOS_IMAGE_PATHS=(
    "$HOME/.local/share/argos/loboMacOS.png"
    "$HOME/.config/argos/loboMacOS.png"
    "$HOME/.local/share/argos/argos-image.png"
    "$HOME/.config/argos/argos-image.png"
)

# Ancho de la imagen en celdas de caracteres. AJUSTA ESTOS VALORES.
# Deben coincidir para que la alineaciÃ³n funcione.
IMAGE_WIDTH_ITERM=25
IMAGE_HEIGHT_ITERM=12

IMAGE_WIDTH_CHAFA=30
IMAGE_HEIGHT_CHAFA=15

# --- FUNCIÃ“N PRINCIPAL ---
# <<< MEJORA: Toda la lÃ³gica estÃ¡ encapsulada en una funciÃ³n para poder ejecutarla en segundo plano. >>>
function argos_main() {
    # Pausa optimizada para iTerm2
    sleep 0.05

    # OptimizaciÃ³n: Solo limpiar procesos si realmente existen
    local existing_processes
    existing_processes=$(pgrep -f "$(basename "$0")" | grep -v $$)
    if [[ -n "$existing_processes" ]]; then
        echo "$existing_processes" | xargs -r kill &>/dev/null
    fi

    local ARGOS_IMAGE=""
    # Buscar la imagen en las rutas definidas
    for path in "${ARGOS_IMAGE_PATHS[@]}"; do
        if [[ -r "$path" ]]; then # -r verifica que el archivo existe Y se puede leer
            ARGOS_IMAGE="$path"
            break
        fi
    done

    # Si no se encontrÃ³ ninguna imagen, no mostrar nada y salir limpiamente.
    if [[ -z "$ARGOS_IMAGE" ]]; then
        # echo "âš ï¸ Imagen ARGOS no encontrada." >&2 # Descomentar para depurar
        return 1
    fi

    # --- GeneraciÃ³n de Texto ---
    # <<< MEJORA: El texto se define una sola vez y se reutiliza. >>>
    local USERNAME
    USERNAME=$(whoami)
    local TEXT_INFO
    TEXT_INFO=$(printf "
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•

        ğŸº W O L F   S Y S T E M ğŸº

    ğŸ‘¤ %s
" "$USERNAME")

    # Limpiar pantalla antes de dibujar
    clear

    # --- LÃ³gica de Dibujado Lado a Lado ---
    # OptimizaciÃ³n: Cache de detecciÃ³n de imgcat
    local IMGCAT_PATH=""
    if [[ -n "${IMGCAT_CACHED:-}" ]]; then
        IMGCAT_PATH="$IMGCAT_CACHED"
    elif command -v imgcat &>/dev/null; then
        IMGCAT_PATH="imgcat"
        export IMGCAT_CACHED="$IMGCAT_PATH"
    elif [[ -x "$HOME/.local/bin/imgcat" ]]; then
        IMGCAT_PATH="$HOME/.local/bin/imgcat"
        export IMGCAT_CACHED="$IMGCAT_PATH"
    elif [[ -x "$(dirname "$0")/imgcat" ]]; then
        IMGCAT_PATH="$(dirname "$0")/imgcat"
        export IMGCAT_CACHED="$IMGCAT_PATH"
    fi

    if [[ "$TERM_PROGRAM" == "iTerm.app" || "$LC_TERMINAL" == "iTerm2" ]] && [[ -n "$IMGCAT_PATH" ]]; then
        # MÃ©todo optimizado para iTerm2
        "$IMGCAT_PATH" --width "$IMAGE_WIDTH_ITERM" --height "$IMAGE_HEIGHT_ITERM" "$ARGOS_IMAGE"

        # OptimizaciÃ³n: Procesamiento de texto mÃ¡s eficiente
        local text_output=""
        local line_num=0
        while IFS= read -r line; do
            text_output+="\033[${line_num};26H${line}\n"
            ((line_num++))
        done <<< "$TEXT_INFO"

        # Imprimir todo el texto de una vez
        printf "$text_output"

    elif command -v chafa &>/dev/null; then
        # MÃ©todo para otras terminales con 'chafa'
        # <<< MEJORA: Se usa 'paste' con sustituciÃ³n de procesos, que es mÃ¡s limpio que archivos temporales. >>>
        paste -d' ' \
            <(chafa --symbols=block --size="${IMAGE_WIDTH_CHAFA}x${IMAGE_HEIGHT_CHAFA}" "$ARGOS_IMAGE") \
            <(echo "$TEXT_INFO")
    else
        # Fallback si no hay visor de imÃ¡genes: solo mostrar el texto
        echo "$TEXT_INFO"
    fi

    # Salto de lÃ­nea final para que el prompt no quede pegado
    echo
}

# --- EJECUCIÃ“N ---
# <<< MEJORA CLAVE: Ejecuta la funciÃ³n directamente para mostrar bienvenida. >>>
# Si se ejecuta desde .zshrc, debe ejecutarse en primer plano para mostrarse correctamente.
argos_main
